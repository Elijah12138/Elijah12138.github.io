[{"id":"b0edff7933712e1475e41d64a8c8ac8c","title":"mlt常用方法","content":"121312312312312\n","slug":"mlt常用方法","date":"2022-06-30T13:27:12.000Z","categories_index":"机器学习,深度学习,Matplotlib","tags_index":"机器学习,深度学习,Matplotlib","author_index":"Elijah"},{"id":"def2b3edec673bcc6047d2d81dfd1856","title":"Git常见问题-Deployer not found git","content":"\n\n\n\n\n\n\n\n\nnpm install hexo-deployer-git –save\n","slug":"Git常见问题-Deployer not found git","date":"2022-06-28T14:17:00.000Z","categories_index":"Git,Hexo","tags_index":"Git,Hexo","author_index":"Elijah"},{"id":"9e6e6987ef0095efdfe7b551204f80c4","title":"Git常见问题-OpenSSL SSL_read Connection was reset","content":"\n\n\n\n\n\n\n\n\ngit config –global http.sslVerify “false”\n","slug":"Git常见问题-OpenSSL SSL_read Connection was reset","date":"2022-06-28T14:14:46.000Z","categories_index":"Git,Hexo","tags_index":"Git,Hexo","author_index":"Elijah"},{"id":"b59fc62089fc87143e9d813fcf584fc0","title":"树莓派 PICO基础教程（基于MicroPython）","content":"树莓派 PICO基础教程（基于MicroPython）[TOC]\n1 树莓派 PICO 简介1.1 简介　　Raspberry Pi Pico是具有灵活数字接口的低成本，高性能微控制器板。它集成了Raspberry Pi自己的RP2040微控制器芯片，运行速度高达133 MHz的双核Arm Cortex M0 +处理器，嵌入式264KB SRAM和2MB板载闪存以及26个多功能GPIO引脚。对于软件开发，可以使用Raspberry Pi的C &#x2F; C ++ SDK或MicroPython。^1\n1.2 配置 ^2\n\n\n树莓派 PICO配置\n\n\n\n双核 Arm Cortex-M0 + @ 133MHz\n\n\n2 个 UART、2 个 SPI 控制器和 2 个 I2C 控制器\n\n\n芯片内置 264KB SRAM 和 2MB 的板载闪存\n\n\n16 个 PWM 通道\n\n\n通过专用 QSPI 总线支持最高 16MB 的片外闪存\n\n\nUSB 1.1 主机和设备支持\n\n\nDMA 控制器\n\n\n8 个树莓派可编程 I&#x2F;O（PIO）状态机，用于自定义外围设备支持\n\n\n30 个 GPIO 引脚，其中 4 个可用作模拟输入\n\n\n支持 UF2 的 USB 大容量存储启动模式，用于拖放式编程\n\n\n1.3 引脚图\n1.4 尺寸\n\n\n2 安装2.1 烧录固件\n点击 https://micropython.org/download/rp2-pico/rp2-pico-latest.uf2 链接下载UF2文件；\n\n\n\n\n\n\n\n\n\n\n如果连接失效，可以进入 https://www.raspberrypi.org/documentation/rp2040/getting-started/#getting-started-with-micropython官网下载\n\n按住BOOTSEL键不放，将Pico插入电脑的USB串口，电脑上会弹出一个新的U盘文件夹，把刚刚下载的UF2文件拖拽到文件夹中，树莓派 PICO将会自动重启，此时，固件烧录完成。\n\n2.2 安装IDE（Thonny IDE）\n进入软件官网 https://thonny.org/下载软件，最好下载最新版的，否则可能不支持树莓派 PICO；\n安装Thonny，安装完成后打开Thonny软件，打开工具-&gt;设置-&gt; 解释器，选择MicroPython(Raspberry Pi Pico)解释器，并在串口处选择树莓派PICO的串口号（如果板子已经连接在电脑上，软件一般会自动检测串口号）\n重启软件，可以看到软件左下方显示了树莓派PICO中的文件；\n\n\n\n\n\n\n\n\n\n\n如果没有显示左侧文件树的话可以勾选 视图-&gt;文件\n2.3 离线运行程序\n　　新建文件，编写完代码后，按住ctrl+s将该文件保存在树莓派PICO上，并命名为main.py(一定要加后缀.py)，下次树莓派PICO通电时便会自动运行main.py中的程序。\n3 基础3.01 点亮板载LED灯from machine import Pin\n\nif __name__ == '__main__':\n    # 构建led对象\n    # 板载LED灯连接与引脚25相连\n    # LED = Pin(id, mode, pull)\n    # id:PICO引脚编号\n    # mode:输入输出方式，有Pin.IN(输入)和Pin.OUT(输出)两种\n    # pull:上下拉电阻配置，有None(无上下拉电阻)、Pin.PULL_UP(上拉电阻)和Pin.PULL_DOWN(下拉电阻)三种\n    LED = Pin(25, Pin.OUT)\n    # 高电平点亮\n    LED.value(1)\n\n3.02 板载LED闪烁from machine import Pin\nfrom utime import sleep\nimport utime\n\nled = Pin(25, Pin.OUT)\n\nif __name__ == '__main__':\n    while True:\n        # led点亮\n        led.value(1)\n        utime.sleep_ms(1000)\n        # led熄灭\n        led.value(0)\n        utime.sleep_ms(1000)\n\n3.03 LED流水灯\nLED发光二极管图片\n\n\n\nLED发光二极管正负极区分\n\n\n一般引脚长的一端为正极，引脚短的为负极\n看发光二极管内部，支架大的为负极，支架小的为负极\n\n\n电路连线图\n\n\n\n\n代码\n\nfrom machine import Pin\nimport utime\n\n# 定义LED引脚数组\nleds = [Pin(i,Pin.OUT) for i in range(0,5)]\n\nif __name__ == '__main__':\n    while True:\n        # 依次点亮\n        for n in range(0,5):\n            leds[n].value(1)\n            utime.sleep_ms(200)\n        # 依次熄灭\n        for n in range(0,5):\n            leds[n].value(0)\n            utime.sleep_ms(100)\n\n\n3.04 按键实验\n四角按键图片\n\n\n\n四角按键怎么连接\n\n\n默认按键未按下的情况下，12相连接，34相连接；当按下按键时，1234才相连接。\n\n电路接线图\n\n\n\n\n代码\n\nfrom machine import Pin\nimport utime\n\n# 配置按键\n# key = machine.Pin(id, mode, pull)\n# id:树莓派Pico引脚编号\n# mode:输入输出方式，有Pin.IN(输入)和Pin.OUT(输出)两种\n# pull:上下拉电阻配置，有None(无上下拉电阻)、Pin.PULL_UP(上拉电阻)和Pin.PULL_DOWN(下拉电阻)三种\nkey = Pin(0, Pin.IN, Pin.PULL_UP)\n\nif __name__ == '__main__':\n    while True:\n        # print(key.value())\n        if key.value() == 0:\n            # 等待一段时间，防止抖动\n            utime.sleep_ms(100)\n            if key.value() == 0:\n                print('The button is pressed')\n\n\n\n\n\n\n\n\n\n\n按键消抖可以参考https://baike.baidu.com/item/%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96\n3.05 外部中断(改进3.04 按键实验)\n什么是外部中断\n\n　　外部中断是单片机实时地处理外部事件的一种内部机制。当某种外部事件发生时，单片机的中断系统将迫使CPU暂停正在执行的程序，转而去进行中断事件的处理；中断处理完毕后．又返回被中断的程序处，继续执行下去。^3\n\n外部中断的作用\n\n\n节省CPU资源\n\n\n代码实现\n\n　　在3.04 按键实验中，检测按键是否被按下采用的是在主程序中写死循环的办法，假如这个按键被按下的频率十分低（一天只有几次被按下），采用死循环的方法将会浪费大量的CPU资源，而采用外部中断的方式检测按键是否被按下将大大节省CPU资源。\nfrom machine import Pin\nimport utime\n\n#配置按键\nkey = Pin(0, Pin.IN, Pin.PULL_UP)\n\ndef external_interrupt(key):\n    # 消除抖动\n    utime.sleep_ms(100)\n    # 再次判断按键是否被按下\n    if key.value() == 0:\n        print('The button is pressed')\n\nif __name__ == '__main__':\n    # KEY.irq(handler,trigger)\n    # handler:中断执行的回调函数\n    # trigger:触发中断的方式，分别为Pin.IRQ_FALLING(下降沿触发)、\n    # Pin.IRQ_RISING(上升沿触发)、Pin.IRQ_LOW_LEVEL(低电平触发)和\n    # Pin.IRQ_HIGH_LEVEL(高电平触发)四种\n    # 定义中断，下降沿触发\n    key.irq(external_interrupt, Pin.IRQ_FALLING)\n\n3.06 定时器中断(改进3.02 板载LED闪烁)\n什么是定时器中断\n\n\n定时器中断是由单片机中的定时器溢出而申请的中断，即设定一个时间，到达这个时间后就会产生中断\n\n\n代码\n\n通过设置定时器中断使树莓派PICO板载LED每隔两秒闪烁一次\nfrom machine import Pin, Timer\n\n# 创建LED对象\nled=Pin(25, Pin.OUT)\n\n# 闪烁回调函数\ndef twinkle(tim):\n    # toggle方法:LED状态翻转\n    led.toggle()\n\nif __name__ == '__main__':\n    # 构建定时器\n    tim = Timer()\n    # tim.init(period, mode, callback)\n    # period:周期时间(单位为ms)\n    # mode:工作模式，有Timer.ONE_SHOT(执行一次)和Timer.PERIODIC(周期性执行)两种\n    # callback:定时器中断的回调函数\n    tim.init(period=2000, mode=Timer.PERIODIC, callback=twinkle)\n\n3.07 PWM 脉冲宽度调制(实现板载LED呼吸灯)\n什么是PWM\n\n　　脉冲宽度调制是一种模拟控制方式，根据相应载荷的变化来调制晶体管基极或MOS管栅极的偏置，来实现晶体管或MOS管导通时间的改变，从而实现开关稳压电源输出的改变。这种方式能使电源的输出电压在工作条件变化时保持恒定，是利用微处理器的数字信号对模拟电路进行控制的一种非常有效的技术。脉冲宽度调制是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在从测量、通信到功率控制与变换的许多领域中。^4\n\n代码\n\nfrom machine import Pin, Timer, PWM\nimport utime\n\nled = PWM(Pin(25))\n# 设置频率值\nled.freq(1000)\n\nled_value = 0\n# led以5%增长/减少的速度变化亮度\nled_space = 5\n\nif __name__ == '__main__':\n    while True:\n        led_value += led_space\n        if led_value >= 100:\n            led_value = 100\n            led_space = -5\n        elif led_value &lt;= 0:\n            led_value = 0\n            led_space = 5\n        # 设置占空比，需在0-65535之间\n        led.duty_u16(int(led_value * 500))\n        utime.sleep_ms(100)\n\n\n3.08 I2C总线(使用SSD1306 OLED屏幕)\nI2C总线简介\n\n　　I2C总线是由Philips公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的器件之间传送信息。I2C由 2 条线组成：SDA（串行数据线）和SCL（串行时钟线），都是双向I&#x2F;O线。^5\n\nSSD1306 OLED简介\n\n　　SSD1306是一款带控制器的用于OLED点阵图形显示系统的单片CMOS OLED&#x2F;PLED驱动器。它由128个SEG（列输出）和64个COM（行输出）组成。该芯片专为共阴极OLED面板设计。  SSD1306内置对比度控制器、显示RAM（GDDRAM）和振荡器，以此减少了外部元件的数量和功耗。该芯片有256级亮度控制。数据或命令由通用微控制器通过硬件选择的6800&#x2F;8000系通用并行接口、I2C接口或串行外围接口发送。该芯片适用于许多小型便携式应用，如手机副显示屏、MP3播放器和计算器等。^6\n\n电路连线图\n\n\n\n代码\n\n\n\n\n\n\n\n\n\n\nssd1306.py下载地址： https://elijah.lanzoui.com/iJ13fpnq6je\n下载完成后，在Thonny软件左侧的文件窗口内找到这个文件，右键点击文件，选择上载到选项，文件即可传输到树莓派PICO上\nfrom machine import SoftI2C, Pin\n# 导入SSD1306驱动模块\nfrom ssd1306 import SSD1306_I2C\n\nif __name__ == '__main__':\n    # 初始化SoftI2C\n    # OLED屏幕的scl连接到树莓派PICO的GPIO0, sda连接到GPIO1\n    i2c = SoftI2C(scl=Pin(0), sda=Pin(1))\n    # oled = SSD1306_I2C(width, height, i2c, addr)\n    # width:屏幕宽\n    # height: 屏幕高\n    # i2c:已定义的I2C对象\n    oled = SSD1306_I2C(128, 64, i2c) #OLED显示屏初始化：128*64分辨率,OLED的I2C地址是0x3c\n    # OLED显示的字符串，横坐标和纵坐标\n    oled.text(\"Hello World!\", 0, 0)\n    # OLED显示\n    oled.show()\n\n\n4 传感器程序4.1 温度传感器(DS18B20)DS18B20是常用的数字温度传感器，其输出的是数字信号，具有体积小，硬件开销低，抗干扰能力强，精度高的特点。\n\n测温范围: -55℃～+125℃，固有测温误差1℃\n\n工作电源: 3.0~5.5V&#x2F;DC\n\n单总线驱动，只占用一个IO口\n\n\nimport machine, onewire, ds18x20, time, utime\n\n# 使用GPIO0口传输数据\n# 将DS18B20的VCC端连接到树莓派PICO的3V3(OUT)端\n# 将DS18B20的数据端连接到树莓派PICO的GPIO0口\n# 将DS18B20的GND端连接到树莓派PICO的GND端\npin = machine.Pin(0)\nsensor = ds18x20.DS18X20(onewire.OneWire(pin))\n\n# 扫描是否存在DS18B20设备\nroms = sensor.scan()\nprint('Found a ds18x20 device')\n\n# 获取温度数据\ndef detect_tem():\n    while True:\n      sensor.convert_temp()\n      for rom in roms:\n        # 打印出温度值\n        # 第一个打印出来的数值可能不太准确，从第二条数据开始才会显示出正常数据\n        print(\"&#123;:.3f&#125;\".format(sensor.read_temp(rom)))  \n      utime.sleep_ms(2000)\n      \n# 程序入口\nif __name__ == '__main__':\n    detect_tem()\n\n4.2 温湿度传感器\n\n\n\n\n\n\n\n\nDHT22.py文件下载地址： https://elijah.lanzoui.com/iFueapnq6id\n文件上传方法参考3.08 I2C总线\n4.2.1 DHT11DHT11是一款有已校准数字信号输出的温湿度传感器。 其精度湿度±5%RH， 温度±2℃，量程湿度5-95%RH， 温度0-+50℃。^9\nfrom machine import Pin\nfrom DHT22 import DHT22\nimport utime\n\npin = Pin(0,Pin.IN,Pin.PULL_UP)\n# 创建dht11对象\n# 将DHT11的VCC端连接到树莓派PICO的3V3(OUT)端\n# 将DHT11的数据端连接到树莓派PICO的GPIO0口\n# 将DHT11的GND端连接到树莓派PICO的GND端\ndht_sensor=DHT22(pin, dht11=True)\n\n# 循环函数\ndef detection():\n    while True:\n        T, H = dht_sensor.read()\n        if T is None:\n            print(\"sensor error\")\n        else:\n            print(\"&#123;&#125;'C  &#123;&#125;%\".format(T, H))\n        utime.sleep_ms(2000)\n\n# 程序入口\nif __name__ == '__main__':    \n    detection()\n\n4.2.1 DHT22　　DHT22也称AM2302，是一款含有已校准数字信号输出的温湿度复合传感器，湿度量程范围0-99.9%RH，精度±2%RH，而温度量程范围是-40℃-80℃，精度±0.5℃。^10\nfrom machine import Pin\nfrom DHT22 import DHT22\nimport utime\n\npin = Pin(0,Pin.IN,Pin.PULL_UP)\n# 创建dht11对象\n# 将DHT11的VCC端连接到树莓派PICO的3V3(OUT)端\n# 将DHT11的数据端连接到树莓派PICO的GPIO0口\n# 将DHT11的GND端连接到树莓派PICO的GND端\ndht_sensor=DHT22(pin, dht11=False)\n\n# 循环函数\ndef detection():\n    while True:\n        T, H = dht_sensor.read()\n        if T is None:\n            print(\"sensor error\")\n        else:\n            print(\"&#123;:.2f&#125;'C  &#123;:.2f&#125;%\".format(T, H))\n        utime.sleep_ms(2000)\n\n# 程序入口\nif __name__ == '__main__':    \n    detection()\n\n\n\n","slug":"树莓派 PICO基础教程（基于MicroPython）","date":"2022-06-28T14:01:30.000Z","categories_index":"MCU,树莓派pico,MicroPython","tags_index":"树莓派pico,MicroPython","author_index":"Elijah"}]